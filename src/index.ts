'use strict';

import Fluence from 'fluence';
import {faasDev, Node} from './environments';
import {FluenceClient} from 'fluence/dist/fluenceClient';
import log from 'loglevel';
import promiseRetry from 'promise-retry';

// NodeJS imports
import {promises as fs} from 'fs';

const TTL = 20000;

type ModuleConfig = {
	name: ModuleName;
	logger_enabled: boolean;
	mounted_binaries: any | undefined;
	wasi: {
		preopened_files: string[],
		mapped_dirs: any | undefined
	};
	mem_pages_count: number
};

type ModuleName = 'redis' | 'curl' | 'sqlite3' | 'history' | 'userlist' | 'facade_url_downloader' | 'local_storage';
type BlueprintName = 'Redis' | 'SQLite 3' | 'User List' | 'Message History' | 'URL Downloader' | 'Chat App';
type Module = {
	base64: string,
	config: ModuleConfig
};
type Blueprint = {
	uuid: string,
	name: BlueprintName,
	dependencies: ModuleName[],
};

type ConfigArgs = {
	name: ModuleName,
	mountedBinaries?: any,
	preopenedFiles?: string[],
	mappedDirs?: any
}

function config(args: ConfigArgs): ModuleConfig {
	return {
		name: args.name,
		mem_pages_count: 100,
		logger_enabled: true,
		mounted_binaries: args.mountedBinaries,
		wasi: {
			preopened_files: args.preopenedFiles || [],
			mapped_dirs: args.mappedDirs,
		}
	};
}

class Distributor {
	blueprints: Blueprint[];
	nodes: Node[];
	modules: Module[];

	// If innerClient is set, it will be used for all requests. Otherwise, a new client will be generated on each request.
	innerClient?: FluenceClient;

	constructor(nodes: Node[], optionalClient?: FluenceClient) {
		this.nodes = nodes;
		this.innerClient = optionalClient;

		this.blueprints = [
			{
				name: 'SQLite 3',
				uuid: '623c6d14-2204-43c4-84d5-a237bcd19874',
				dependencies: ['sqlite3']
			},
			{
				name: 'User List',
				uuid: '1cc9f08d-eaf2-4d27-a273-a52cb294a055',
				dependencies: ['sqlite3', 'userlist']
			},
			{
				name: 'Message History',
				uuid: 'bbe13303-48c9-407f-ac74-88f26dc4bfa7',
				dependencies: ['sqlite3', 'history']
			},
			{
				name: 'URL Downloader',
				uuid: 'f247e046-7d09-497d-8330-9a41d6c23756',
				dependencies: ['local_storage', 'curl', 'facade_url_downloader']
			},
			{
				name: 'Redis',
				uuid: 'b3a22bb4-4ba9-4517-90b1-45cc97f7a610',
				dependencies: ['redis'],
			}
		];

		this.modules = [];
	}

	async load_modules() {
		this.modules = [
			{
				base64: await loadWasmModule('url-downloader/curl.wasm'),
				config: config({name: 'curl', mountedBinaries: {curl: '/usr/bin/curl'}, preopenedFiles: ['/tmp']})
			},
			{
				base64: await loadWasmModule('url-downloader/local_storage.wasm'),
				config: config({name: 'local_storage', preopenedFiles: ['/tmp'], mappedDirs: {sites: '/tmp'}})
			},
			{
				base64: await loadWasmModule('url-downloader/facade.wasm'),
				config: config({name: 'facade_url_downloader'})
			},
			{base64: await loadWasmModule('sqlite3.wasm'), config: config({name: 'sqlite3'})},
			{base64: await loadWasmModule('user-list.wasm'), config: config({name: 'userlist'})},
			{base64: await loadWasmModule('history.wasm'), config: config({name: 'history'})},
			{base64: await loadWasmModule('redis.wasm'), config: config({name: 'redis'})},
		];
	}

	async makeClient(node: Node): Promise<FluenceClient> {
		if (typeof this.innerClient !== 'undefined') {
			return this.innerClient;
		} else {
			return await Fluence.connect(node.multiaddr);
		}
	}

	async uploadModule(node: Node, module: Module) {
		const client = await this.makeClient(node);
		log.warn(`uploading module ${module.config.name} to node ${node.peerId} via client ${client.selfPeerId.toB58String()}`);

		await client.addModule(module.config.name, module.base64, module.config, node.peerId, TTL);

		// const modules = await client.getAvailableModules(node.peerId, 20000);
		// console.log(`modules: ${JSON.stringify(modules)}`);
	}

	async uploadBlueprint(node: Node, bp: Blueprint): Promise<Blueprint> {
		const client = await this.makeClient(node);
		log.warn(`uploading blueprint ${bp.name} to node ${node.peerId} via client ${client.selfPeerId.toB58String()}`);

		const blueprintId = await client.addBlueprint(bp.name, bp.dependencies, bp.uuid, node.peerId, TTL);
		if (blueprintId !== bp.uuid) {
			log.error(`NON-CONSTANT BLUEPRINT ID: Expected blueprint id to be predefined as ${bp.uuid}, but it was generated by node as ${blueprintId}`);
			return {...bp, uuid: blueprintId};
		}

		return bp;
	}

	async createService(node: Node, bp: Blueprint): Promise<string> {
		const client = await this.makeClient(node);
		log.warn(`creating service ${bp.name}@${bp.uuid} via client ${client.selfPeerId.toB58String()}`);

		const serviceId = await client.createService(bp.uuid, node.peerId, TTL);
		log.warn(`service created ${serviceId} as instance of ${bp.name}@${bp.uuid} via client ${client.selfPeerId.toB58String()}`);

		return serviceId;
	}

	async uploadAllModules(node: Node) {
		for (const module of this.modules) {
			await this.uploadModule(node, module);
		}
	}

	async uploadAllModulesToAllNodes() {
		for (const node of this.nodes) {
			await this.uploadAllModules(node);
		}
	}

	async uploadAllBlueprints(node: Node) {
		for (const bp of this.blueprints) {
			await this.uploadBlueprint(node, bp);
		}
	}

	async uploadAllBlueprintsToAllNodes() {
		for (const node of this.nodes) {
			await this.uploadAllBlueprints(node);
		}
	}

	async distributeServices(relay: Node, distribution: Map<BlueprintName, number[]>) {
		// this.innerClient = await this.makeClient(relay);

		// Cache information about uploaded modules & blueprints to avoid uploading them several times
		const uploadedModules = new Set<[Node, ModuleName]>();
		const uploadedBlueprints = new Set<[Node, BlueprintName]>();

		async function uploadM(d: Distributor, node: Node, module: Module) {
			const already = uploadedModules.has([node, module.config.name]);
			if (!already) {
				await promiseRetry({retries: 3}, () => d.uploadModule(node, module));
			}
			uploadedModules.add([node, module.config.name]);
		}

		async function uploadB(d: Distributor, node: Node, bp: Blueprint): Promise<Blueprint> {
			const already = uploadedBlueprints.has([node, bp.name]);
			if (!already) {
				const blueprint = await promiseRetry({retries: 3}, () => d.uploadBlueprint(node, bp));
				uploadedBlueprints.add([node, bp.name]);
				return blueprint;
			}

			return bp;
		}

		for (const [name, nodes] of distribution.entries()) {
			const blueprint = this.blueprints.find(bp => bp.name === name);
			if (!blueprint) {
				throw new Error(`can't find blueprint ${name}`);
			}

			const modules: [ModuleName, Module | undefined][] = blueprint.dependencies.map(
				(moduleName) => [
					moduleName,
					this.modules.find(m => m.config.name === moduleName)
				]
			);

			for (const idx of nodes) {
				const node = this.nodes[idx];
				for (const [nameM, module] of modules) {
					if (module) {
						await uploadM(this, node, module);
					} else {
						throw new Error(`can't find dependency ${nameM} for bluprint ${blueprint.name}`)
					}
				}
				const bp = await uploadB(this, node, blueprint);
				await this.createService(node, bp);
			}
		}
	}
}

// For use in browser
interface MyNamespacedWindow extends Window {
	nodes: Node[]
	distributor: Distributor
	distribute: (() => Promise<void>);
}

declare var window: MyNamespacedWindow;
try {
	window.nodes = faasDev;
	window.distribute = distribute;
	window.distributor = new Distributor(window.nodes);
} catch (e) {
	//
}

// @ts-ignore
export async function distribute() {
	const nodes = faasDev;
	const distributor = new Distributor(nodes);
	await distributor.distributeServices(nodes[0], new Map([
		// ['SQLite 3', [1, 2, 3, 4]],
		['User List', [1, 1]],
		['Message History', [1, 1, 1]],
		// ['Redis', [5,6,7,8]]
	])).then(_ => log.warn('finished'));
}

export async function loadWasmModule(name: string): Promise<string> {
	const data = await fs.readFile('./src/artifacts/' + name);
	const base64data = data.toString('base64');
	return base64data;
}

if (typeof process === 'object') {
	Fluence.setLogLevel('warn');
	log.setLevel('warn');

	console.log(`log level is ${log.getLevel()}`);

	// we're running in Node.js
	log.warn('hello, node!');

	((async () => {
		const distributor = new Distributor(faasDev);
		await distributor.load_modules();
		await distributor.distributeServices(faasDev[0], new Map([
			// ['SQLite 3', [1, 2, 3, 4]],
			['User List', [1, 1]],
			['Message History', [1, 1, 1]],
			// ['Redis', [5,6,7,8]]
		])).then(_ => log.warn('finished'));
		// await log.warn(await loadWasmModule('history.wasm'));
	})());
}