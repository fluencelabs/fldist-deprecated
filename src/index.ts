'use strict';

import Fluence from 'fluence';
// import {FluenceSender} from "./fluenceSender";
// import {getPageType} from "./index";
import {curl} from './artifacts/curl';
import {SQLITE_BS64} from './artifacts/sqliteBs64';
import {USER_LIST_BS64} from './artifacts/userListBs64';
import {local_storage} from './artifacts/local_storage';
import {facade as url_downloader_facade} from './artifacts/facade';
import {Node, stage} from './environments';
import {FluenceClient} from 'fluence/dist/fluenceClient';
import log from 'loglevel';

const TTL = 20000;

type Config = {
	logger_enabled: boolean;
	module: { mounted_binaries: any };
	wasi: { preopened_files: string[] };
	name: string;
	mem_pages_count: number
};

type ModuleName = 'curl' | 'sqlite' | 'history' | 'userlist' | 'url_downloader' | 'local_storage';
type Module = { name: ModuleName, base64: string };
type Blueprint = {
	uuid: string,
	name: string,
	dependencies: ModuleName[],
};

class Distributor {
	blueprints: Blueprint[] = [];
	modules: Module[];

	// If innerClient is set, it will be used for all requests. Otherwise, a new client will be generated on each request.
	innerClient?: FluenceClient;

	constructor(optionalClient?: FluenceClient) {
		Fluence.setLogLevel('trace');

		this.innerClient = optionalClient;

		this.blueprints = [
			{
				name: 'sqlite',
				uuid: '623c6d14-2204-43c4-84d5-a237bcd19874',
				dependencies: ['sqlite']
			},
			{
				name: 'user_list',
				uuid: '1cc9f08d-eaf2-4d27-a273-a52cb294a055',
				dependencies: ['sqlite', 'userlist']
			},
			{
				name: 'history',
				uuid: 'bbe13303-48c9-407f-ac74-88f26dc4bfa7',
				dependencies: ['sqlite', 'history']
			},
			{
				name: 'url_downloader',
				uuid: 'f247e046-7d09-497d-8330-9a41d6c23756',
				dependencies: ['local_storage', 'curl', 'url_downloader']
			},
		];

		this.modules = [
			{name: 'curl', base64: curl},
			{name: 'sqlite', base64: SQLITE_BS64},
			{name: 'userlist', base64: USER_LIST_BS64},
			{name: 'url_downloader', base64: url_downloader_facade},
			{name: 'local_storage', base64: local_storage},
			{name: 'curl', base64: curl},
			// { name: 'history', base64: history },
		];
	}

	async makeClient(node: Node): Promise<FluenceClient> {
		if (typeof this.innerClient !== 'undefined') {
			return this.innerClient;
		} else {
			return await Fluence.connect(node.multiaddr);
		}
	}

	async uploadModule(node: Node, module: Module) {
		const client = await this.makeClient(node);
		log.info(`uploading module ${module.name} via client ${client.selfPeerId.toB58String()}`);

		const cfg = config(module.name);
		await client.addModule(module.name, module.base64, cfg, node.peerId, TTL);

		// const modules = await client.getAvailableModules(node.peerId, 20000);
		// console.log(`modules: ${JSON.stringify(modules)}`);
	}

	async uploadBlueprint(node: Node, bp: Blueprint): Promise<Blueprint> {
		const client = await this.makeClient(node);
		log.info(`uploading blueprint ${bp.name} via client ${client.selfPeerId.toB58String()}`);

		const blueprintId = await client.addBlueprint(bp.name, bp.dependencies, bp.uuid, node.peerId, TTL);
		if (blueprintId !== bp.uuid) {
			log.error(`NON-CONSTANT BLUEPRINT ID: Expected blueprint id to be predefined as ${bp.uuid}, but it was generated by node as ${blueprintId}`);
			return { ...bp, uuid: blueprintId };
		}

		return bp;
	}

	async createService(node: Node, bp: Blueprint): Promise<string> {
		const client = await this.makeClient(node);
		log.info(`creating service ${bp.name}@${bp.uuid} via client ${client.selfPeerId.toB58String()}`);

		const serviceId = await client.createService(bp.uuid, node.peerId, TTL);
		log.info(`service created ${serviceId} as instance of ${bp.name}@${bp.uuid} via client ${client.selfPeerId.toB58String()}`);

		return serviceId;
	}

	async uploadAllModules(node: Node) {
		for (const module in this.modules) {
			this.uploadModule(node, module)
		}
	}
}

function config(name: string): Config {
	return {
		name,
		mem_pages_count: 100,
		logger_enabled: true,
		module: {
			mounted_binaries: {
				curl: '/usr/bin/curl'
			}
		},
		wasi: {
			preopened_files: ['/tmp'],
		}
	};
}

// export async function uploadModule(client: FluenceClient, name: string, base64: string) {
// 	Fluence.setLogLevel('trace');
//
// 	const node = stage[0];
// 	const client = await Fluence.connect(node.multiaddr);
// 	console.log(`client peer id is ${client.selfPeerId.toB58String()}`);
// 	const cfg = config(name);
// 	await client.addModule(name, base64, cfg, node.peerId, 20000);
//
// 	const modules = await client.getAvailableModules(node.peerId, 20000);
// 	console.log(`modules: ${JSON.stringify(modules)}`);

	// const historyName = 'history'
	// const userListName = 'user-list'
	//
	// await cl.addModule('curl', curl, peerId, 20000, c1);
	// const c2 = {
	// 	name: 'local_storage',
	// 	mem_pages_count: 100,
	// 	logger_enabled: true,
	// 	wasi: {
	// 		preopened_files: ['/sites'],
	// 		mapped_dirs: {sites: '/sites'},
	// 	}
	// }
	//
	// await cl.addModule('local_storage', local_storage, peerId, 20000, c2);
	// const c5 = {
	// 	name: 'facade_url_downloader',
	// 	mem_pages_count: 100,
	// 	logger_enabled: true
	// }
	// await cl.addModule('facade_url_downloader', facade, peerId, 20000);
	// console.log('5555')
	// const blueprintId = await cl.addBlueprint('Url-Downloader', ['local_storage', 'curl', 'facade_url_downloader'], URL_DOWNLOADER)
	// // let blueprintIdUserList = await cl.addBlueprint("UserList", ["sqlite3", userListName], USER_LIST_ID)
	// // let blueprintIdSQLite = await cl.addBlueprint("SQLite", ["sqlite3"], SQLITE_ID)
	// console.log(`BLUEPRINT ID: ${blueprintId}`)
	// console.log('66666')
	// // console.log(`BLUEPRINT USER LIST ID: ${blueprintIdUserList}`)
	// // console.log(`BLUEPRINT HISTORY ID: ${blueprintIdSQLite}`)
	//
	// const serviceId = cl.createService(blueprintId, undefined, 20000);
	// console.log('serviceId: ' + serviceId)
	//
	// // await create(cl, num, USER_LIST_ID, HISTORY_ID)
// }

let distributor = new Distributor();
distributor.uploadAllModules(stage[0]);

// uploadModule();

